---
description: Система run_id и запись логов/данных прогона в БД по всему боту
alwaysApply: true
---

# Run_id и запись данных прогона в БД

## Принцип

Любые данные, привязанные к **одному запуску/сессии** (бэктест, лайв-сессия, скрипт), должны идентифицироваться по **run_id** и по возможности храниться в БД, а не только в append-файлах. Так не будет наслоения разных прогонов в одном файле, отчёты и аналитика — по фильтру run_id или по дате.

## Когда вводить run_id

- Новый **скрипт или режим**, который пишет накапливаемые данные (сделки, пропуски, сигналы, метрики по тикам/свечам).
- Любой **бэктест** или **лайв-цикл**, в котором компонент пишет строки в CSV/лог «от имени» этого запуска.

## Как делать

1. **В начале прогона** (в точке входа: `run_backtest()`, создание песочницы в `main.py`, запуск скрипта):
   - Сгенерировать уникальный **run_id** (например `backtest_{symbol}_{date_from}_{date_to}_{timestamp}` или `live_{symbol}_{timestamp}`).
   - Создать запись в таблице **runs** (или доменной, например `sandbox_runs`): run_id, symbol, date_from/date_to (если есть), started_at_sec, source (backtest/live/script).

2. **Передавать run_id** в компоненты, которые пишут данные (песочница, логгеры, агрегаторы): через аргумент конструктора или контекст.

3. **При записи каждой строки** (сделка, пропуск, сигнал и т.д.):
   - Писать в БД в таблицу с колонкой **run_id** (FK на runs), а не только в CSV.
   - CSV можно оставить как дубликат или отключить после перехода на БД.

4. **По завершении прогона** (опционально):
   - Обновить запись run: finished_at_sec, final_equity, total_pnl, trades_count и т.п.

5. **Отчёты и выборка**:
   - Читать из БД с фильтром по run_id или по диапазону дат; при необходимости оставить чтение из CSV (например по пути к файлу) для обратной совместимости.

## Где уже реализовано

- **Песочница:** `sandbox_runs`, `sandbox_trades`, `sandbox_skips` в `src/core/database.py`. Бэктест и лайв создают run_id и передают его в `MicrostructureSandbox`; сделки/пропуски пишутся в БД и в CSV. Отчёт: `sandbox_backtest_report.py --db [--run-id ...] [--year ...]`.

## Добавляя новый «прогон» с логами

- Ввести таблицу(ы) в `database.py` (runs + детальные строки с run_id).
- В точке входа скрипта/лайва — создать run_id, вставить строку в runs, передать run_id в компоненты.
- В компоненте при каждой записи — вставка в БД с этим run_id (и при необходимости append в CSV с архивированием перед новым прогоном, см. правило «Логи и накапливаемые данные» в trading-bot.mdc).

## Чего избегать

- Писать в один и тот же CSV/файл данные нескольких прогонов без run_id и без архивирования перед новым запуском.
- Хранить только в файлах то, что нужно фильтровать по сессии или по дате — предпочтительно БД с run_id.
