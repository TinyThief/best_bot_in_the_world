# Как устроен бот — для нового человека в проекте

Краткий обзор: что это за проект, что уже сделано, за что отвечает каждый файл и как всё связано.

---

## Что это за проект

**Мультитаймфреймовый торговый бот для биржи Bybit.**

Идея: торговать (пока в планах), опираясь на анализ нескольких таймфреймов — тренд со старшего ТФ и вход с младшего. Сейчас реализовано:

1. **Подключение к Bybit** и загрузка свечей по любым таймфреймам.
2. **База данных для обучения** — SQLite с историей OHLCV по фьючерсу BTC на всех таймфреймах; база наращивается со временем.
3. **Мультитаймфреймовый анализ** — тренд и режим рынка по ТФ, 6 фаз, фильтры входа, единый score входа, проверка качества свечей, результирующий сигнал (long/short/none). Пока без реальных сделок.

Торговля ордерами и риск-менеджмент — в планах.

---

## Что уже сделано (кратко)

| Готово | Описание |
|--------|----------|
| ✅ | Клиент Bybit (REST, публичные данные): свечи «последние N» и по диапазону start/end |
| ✅ | Бэкфилл истории: пагинация по 1000 свечей, загрузка вглубь до лимита |
| ✅ | SQLite-база `klines`: symbol, timeframe, start_time, open, high, low, close, volume |
| ✅ | Скрипт накопления БД: при первом запуске — бэкфилл по всем ТФ, потом — периодическое дополнение новыми свечами |
| ✅ | Модуль мультитаймфреймового анализа: тренд и режим по ТФ, 6 фаз, фильтры входа (объём, ATR, уровни, совпадение ТФ, режим «всплеск», качество свечей), единый score входа (фаза + тренд + ТФ), phase_decision_ready, агрегированный сигнал по старшему ТФ |
| ✅ | Определение фаз (Вайкофф + индикаторы): структура, объём у границ, Spring/Upthrust (в т.ч. с подтверждением объёмом), Selling/Buying climax, EMA 20/50/200, ADX, BB width, OBV, VWAP, RSI, контекст старшего ТФ; phase_unclear, score_gap, устойчивость фазы; свинг-уровни (поддержка/сопротивление); подбор порогов `--tune` |
| ✅ | Модуль тренда (`market_trend.py`): detect_trend (структура, EMA, ADX, сила тренда, VWAP, OBV, return 5/20), detect_regime (тренд/диапазон/всплеск по ADX, ATR, BB width) |
| ✅ | Бэктест точности фаз по БД (`backtest_phases.py`), бэктест тренда (`backtest_trend.py`); фильтр `--min-score` и подбор порогов `--tune` для фаз |
| ✅ | Конфиг через `.env`, разделение настроек для «торгового» бота и для «базы под обучение»; пороги фаз, тренда, фильтры входа, режим рынка, единый score входа, качество свечей |
| ✅ | Telegram-бот: при запуске `python main.py` и заданном TELEGRAM_BOT_TOKEN бот поднимается в отдельном потоке (общее соединение с БД); отдельно — `python telegram_bot.py` |
| ⏳ | Реальные сделки, риск-менеджмент — не делали |

---

## Структура по папкам

- **src/core/** — инфраструктура: конфиг (`config.py`), БД (`database.py`), биржа Bybit (`exchange.py`), логирование (`logging_config.py`).
- **src/analysis/** — аналитика: фазы рынка (`market_phases.py` — основной, Вайкофф + индикаторы, свинг-уровни), тренд и режим рынка (`market_trend.py` — detect_trend, detect_regime), мультитаймфреймовый разбор и сигнал (`multi_tf.py`). Экспериментальные модули фаз: только Вайкофф (`phase_wyckoff.py`), только индикаторы (`phase_indicators.py`), только price action / BOS-CHOCH (`phase_structure.py`).
- **src/app/** — приложения: точка входа и цикл (`main.py`), один тик бота — БД + анализ + лог (`bot_loop.py`), синхронизация БД (`db_sync.py`), Telegram-бот (`telegram_bot.py`).
- **src/scripts/** — скрипты: накопление БД (`accumulate_db.py`), бэктест фаз (`backtest_phases.py`), бэктест тренда (`backtest_trend.py`), сравнение методов фаз (`compare_phase_methods.py`), полный бэкфилл (`full_backfill.py`), перезалив ТФ D (`refill_tf_d.py`), тест-прогон (`test_run_once.py`). Импорты из `..core` и `..analysis`.
- **src/utils/** — утилиты: validators, helpers, candle_quality (проверка OHLCV перед анализом), **backtest_chart** (build_phases_chart, build_trend_chart, build_candlestick_trend_chart — свечной график с трендами Вверх/Вниз/Флэт из БД).
- **Корень** — точки входа (`main.py`, `telegram_bot.py`, `accumulate_db.py`, `backtest_phases.py`, `backtest_trend.py`, `compare_phase_methods.py`, `full_backfill.py`, **`refresh_db.py`** — удаление БД и полная загрузка всех ТФ, **`refill_tf_d.py`** — перезалив ТФ D, **`catch_up_db.py`** — догрузка БД до текущей даты, `test_run_once.py`) поднимают `sys.path` и вызывают модули из `src.app` или `src.scripts`. Здесь же `release.py`, `requirements.txt`, `.env.example`, документация, `check_all.py`.
- **strategies/** — заготовка под стратегии (trend_following, scalping и т.д.).
- **tests/** — unit/, integration/, backtest/ для тестов.
- **data/** — каталог для SQLite-базы (`data/klines.db` по умолчанию). **logs/** — каталог логов. Оба в .gitignore.

Запуск из корня: `python main.py`, `python accumulate_db.py`, `python backtest_phases.py` и т.д.

---

## За что отвечает каждый файл

### `src/core/config.py`

**Настройки приложения.** Читает `.env` из корня проекта (`PROJECT_ROOT`), экспортирует константы.

- Bybit: `BYBIT_API_KEY`, `BYBIT_API_SECRET`, `BYBIT_TESTNET`, `BYBIT_CATEGORY`
- Торговый режим: `SYMBOL`, `TIMEFRAMES`, `KLINE_LIMIT`, `POLL_INTERVAL_SEC`, `DATA_SOURCE` (db/exchange), `SIGNAL_MIN_CONFIDENCE`, `EXCHANGE_MAX_RETRIES`, `EXCHANGE_RETRY_BACKOFF_SEC`
- Фазы: `PHASE_SCORE_MIN`, `PHASE_UNCLEAR_THRESHOLD`, `PHASE_MIN_GAP`, `PHASE_STABILITY_MIN`, `PHASE_HISTORY_SIZE`
- Тренд (market_trend): `TREND_STRENGTH_MIN`, `TREND_UNCLEAR_THRESHOLD`, `TREND_MIN_GAP`, `TREND_STABILITY_MIN`
- Фильтры входа: `VOLUME_MIN_RATIO`, `ATR_MAX_RATIO`, `TF_ALIGN_MIN`, `LEVEL_MAX_DISTANCE_PCT`, `REGIME_BLOCK_SURGE` (1 = не входить при режиме «всплеск» по старшему ТФ)
- Единый score входа: `ENTRY_SCORE_WEIGHT_PHASE`, `ENTRY_SCORE_WEIGHT_TREND`, `ENTRY_SCORE_WEIGHT_TF_ALIGN` (веса фазы, тренда, совпадения ТФ)
- Качество свечей: `CANDLE_QUALITY_MIN_SCORE` (0 = не блокировать; при > 0 низкое качество по ТФ блокирует решение о входе)
- База для обучения: `DB_PATH` (по умолчанию `PROJECT_ROOT/data/klines.db`), `TIMEFRAMES_DB`, `BACKFILL_MAX_CANDLES`, `DB_UPDATE_INTERVAL_SEC`, `AUTO_EXTEND_AT_STARTUP` (1/0 — автоматически углублять историю по всем ТФ при подготовке БД).
- Логирование: `LOG_DIR` (каталог, по умолчанию `PROJECT_ROOT/logs`), `LOG_LEVEL`, `LOG_LEVEL_FILE`, `LOG_FILE_MAX_MB`, `LOG_BACKUP_COUNT`, `LOG_SIGNALS_FILE` (1/0 — отдельный файл сигналов).

Есть `validate_config()`, `PROJECT_ROOT`.

---

### `src/core/logging_config.py`

**Единая настройка логирования.** Вызывается в начале `main`, `telegram_bot`, `accumulate_db`, `full_backfill`.

- **`setup_logging()`** — идемпотентно настраивает: вывод в консоль; ротируемый файл `logs/bot.log` (по умолчанию до 10 МБ, 7 архивов); при `LOG_SIGNALS_FILE=1` — компактный `logs/signals.log` (одна строка на каждый тик: direction, reason, higher_tf_phase). В файле в каждой строке есть модуль, функция и номер строки. Уровни задаются через `LOG_LEVEL` и `LOG_LEVEL_FILE`.
- **`get_signals_logger()`** — логгер для записи в `signals.log` (используется из `bot_loop`).

---

### `src/core/exchange.py`

**Всё общение с биржей Bybit.** Используется библиотека `pybit` (REST API V5).

- **`get_klines(...)`** — запрос свечей: пара, интервал, лимит, опционально `start_ms`/`end_ms`. Возвращает список словарей `{ start_time, open, high, low, close, volume }` в порядке от старых к новым.
- **`get_klines_multi_timeframe(...)`** — те же свечи, но сразу по нескольким таймфреймам; результат — словарь `{ "15": [...], "60": [...], ... }`.
- **`fetch_klines_backfill(...)`** — загрузка истории вглубь от заданного `end_ms`: пагинация по 1000 свечей, пока не наберётся `max_candles` или данные не кончатся. Нужна для первоначального наполнения БД.
- **`_filter_valid_ohlc(...)`** — отсев свечей с нереалистичными ценами (для BTCUSDT: 1000–500 000 USDT). Применяется ко всем ответам get_klines и fetch_klines_backfill.

Интервалы Bybit: `1,3,5,15,30,60,120,240,360,720,D,W,M`. Категории: `linear` (USDT-фьючерсы), `inverse`, `spot`.

---

### `src/core/database.py`

**Работа с локальной базой свечей.** Одна SQLite-база, одна таблица `klines`.

- **Схема:** `(symbol, timeframe, start_time, open, high, low, close, volume)`, первичный ключ `(symbol, timeframe, start_time)`.
- **`get_db_path()`** — путь к файлу БД из конфига (по умолчанию `data/klines.db`).
- **`get_connection()`** — открывает соединение и при первом обращении создаёт таблицу и индекс.
- **`init_db()`** — создаёт файл/таблицу, если их ещё нет.
- **`insert_candles(cursor, symbol, timeframe, candles)`** — вставляет список свечей; дубликаты по `(symbol, timeframe, start_time)` игнорируются (`INSERT OR IGNORE`). Возвращает количество реально вставленных строк.
- **`get_latest_start_time(cursor, symbol, timeframe)`** — `start_time` последней свечи по этой паре и ТФ (или `None`).
- **`get_oldest_start_time(...)`** — самая старая свеча по паре/ТФ.
- **`count_candles(...)`** — число строк, опционально с фильтром по symbol/timeframe.
- **`delete_klines_for_symbol(cursor, symbol)`** — удалить все свечи по символу.
- **`delete_klines_for_symbol_timeframe(cursor, symbol, timeframe)`** — удалить все свечи по символу и ТФ.

Используется и для накопления данных, и (в перспективе) для чтения при обучении моделей.

---

### `src/scripts/accumulate_db.py`

**Скрипт, который наполняет и поддерживает базу свечей.** Точка входа для «накопления данных под обучение». Лаунчер в корне: `accumulate_db.py`.

- При старте проверяет `TIMEFRAMES_DB`; если пусто — пишет в лог и выходит.
- Создаёт/открывает БД, затем в цикле по каждому таймфрейму из `TIMEFRAMES_DB`:
  - если по этому ТФ в БД ещё нет данных — делает **бэкфилл** через `exchange.fetch_klines_backfill(...)` (до `BACKFILL_MAX_CANDLES` свечей) и вставляет в БД;
  - в любом случае **дотягивает последние свечи** через `exchange.get_klines(...)` и вставляет только новые.
- **`run_extend_until_done(conn)`** — по каждому ТФ подгружает историю вглубь от самой старой свечи, пока есть новые данные; используется из `db_sync.open_and_prepare()` при `AUTO_EXTEND_AT_STARTUP=1`, чтобы по всем ТФ (в т.ч. 3m) глубина нарастала автоматически без ручного `full_backfill.py --extend`.
- После первого полного прохода засыпает на `DB_UPDATE_INTERVAL_SEC` секунд и снова дотягивает новые свечи по всем ТФ. Так база постоянно растёт.

Пара и категория берутся из конфига (`SYMBOL`, `BYBIT_CATEGORY`). Для чтения свечей ключи API не обязательны.

Запуск: `python accumulate_db.py`. Остановка — Ctrl+C.

---

### `src/analysis/multi_tf.py`

**Мультитаймфреймовый анализ и сигнал.** Тренд и режим рынка по ТФ (через `market_trend`), 6 фаз рынка (через `market_phases`), фильтры входа, направление по старшему ТФ.

- **`analyze_multi_timeframe(...)`** — запрашивает свечи по всем заданным таймфреймам (из БД или биржи), для каждого ТФ считает тренд (`detect_trend`), режим рынка (`detect_regime`: тренд/диапазон/всплеск), фазу (`detect_phase`), устойчивость фазы и тренда; по старшему ТФ — фильтры (объём, ATR, расстояние до свинг-уровней, совпадение ТФ по тренду/фазе, режим «всплеск»). Сигнал long/short выдаётся только при `phase_decision_ready` (фаза ясна и устойчива, тренд ясен, фильтры пройдены, режим не «всплеск», качество свечей ок при `CANDLE_QUALITY_MIN_SCORE > 0`). Единый score входа (0..1) — взвешенная сумма фазы, тренда и доли совпадающих ТФ; `confidence` = entry_score при наличии направления.
  - `higher_tf_trend`, `higher_tf_regime`, `higher_tf_phase`
  - `signals.direction`, `signals.reason`, `signals.phase_decision_ready`, `signals.entry_score`, `signals.entry_score_breakdown`
  - `confidence` (= entry_score при направлении), `confidence_level`

Использует настройки `SYMBOL` и `TIMEFRAMES` из конфига (не `TIMEFRAMES_DB`). При `DATA_SOURCE=db` и переданном соединении с БД читает свечи из локальной БД; при `DATA_SOURCE=exchange` — запрос к Bybit на каждый вызов.

---

### `src/app/main.py` и лаунчер `main.py`

**Точка входа «сигнального» бота.** В `main.py`: валидация конфига, подготовка БД через `db_sync`; при заданном `TELEGRAM_BOT_TOKEN` — запуск Telegram-бота в отдельном потоке (общее соединение с БД); в цикле — `bot_loop.run_one_tick()` и пауза `POLL_INTERVAL_SEC`. Сделок не открывает. Остановка — Ctrl+C. Запуск: `python main.py`. Для работы только без Telegram оставь `TELEGRAM_BOT_TOKEN` пустым или запускай отдельно `python telegram_bot.py`.

### `src/app/bot_loop.py`

**Один тик цикла бота.** Функция `run_one_tick(db_conn, last_db_ts)` обновляет БД по таймеру (`db_sync.refresh_if_due`), запускает мультиТФ-анализ (`analyze_multi_timeframe`) и пишет результат в лог. Вся логика «что делать за один шаг» собрана здесь; `main.py` только вызывает `run_one_tick` в цикле.

### `src/app/db_sync.py`

**Синхронизация БД с биржей во время работы бота.** Используется из `main.py` и Telegram-бота. Функции: `open_and_prepare()` — инициализация, бэкфилл по пустым ТФ, догрузка пропусков, при `AUTO_EXTEND_AT_STARTUP=1` — автоматическое углубление истории по всем ТФ до упора (возвращает соединение или `None`); `refresh_if_due(conn, last_ts)` — при истечении интервала подтягивает новые свечи; `close(conn)` — закрытие соединения. Логика: `scripts.accumulate_db.run_once`, `run_catch_up`, `run_extend_until_done`.

---

### `release.py` (в корне)

**Версии и выгрузка в GitHub.** Создаёт тег версии (например `v1.0.0`), при наличии изменений — коммитит их, пушит текущую ветку и теги в `origin`. Откат: `git checkout v1.0.0`.

- `python release.py 1.0.0` — коммит (если есть изменения), тег `v1.0.0`, push ветки и тега.
- `python release.py 1.0.1 --tag-only` — только тег и push тега, без коммита.
- `python release.py 1.0.0 --no-push` — коммит и тег локально, без отправки.
- Откат: `git checkout v1.0.0`. Список тегов: `git tag -l`.

Перед первым использованием: `git init`, `git remote add origin <url>`.

---

### `src/analysis/market_phases.py`

**6 фаз рынка (Wyckoff + индикаторы):** accumulation, markup, distribution, markdown, capitulation, recovery. `detect_phase(candles, ...)` по OHLCV возвращает phase, phase_ru, score, details.

- **Вайкофф:** структура (HH/HL, LH/LL), позиция в диапазоне, объём у границ, давление объёма, Spring/Upthrust (в т.ч. подтверждение объёмом), Selling/Buying climax, свежесть зоны, сила тренда, RSI и дивергенция RSI, контекст старшего ТФ.
- **Индикаторы:** EMA 20/50/200 (стек), ADX(14), ширина Bollinger Bands, OBV slope, VWAP (rolling). Для markup/markdown учитывается число подтверждений (2+ или 3+ из четырёх).
- При 200+ свечах используется окно 200 баров (для EMA200). Пороги по ТФ заданы в `PHASE_PROFILES` (short/long); для long ТФ подобраны через `--tune`.

Капитуляция = «ожидаем отскок». Используется в `multi_tf` по каждому ТФ. Свинг-уровни (поддержка/сопротивление) — `swing_levels()` для фильтра расстояния цены до уровней.

### `src/analysis/market_trend.py`

**Тренд и режим рынка.** `detect_trend(candles)` — агрегирует структуру (HH/HL, LH/LL), EMA-стек, ADX (+DI/-DI), силу тренда, VWAP, OBV slope, return 5/20; возвращает direction (up/down/flat), strength, trend_unclear, secondary_direction, strength_gap. `detect_regime(candles)` — по ADX, ATR и ширине BB возвращает режим: trend / range / surge (всплеск волатильности). Используется в `multi_tf` по каждому ТФ и для фильтра «не входить при всплеске» по старшему ТФ.

### Бэктест тренда: `src/scripts/backtest_trend.py` и лаунчер `backtest_trend.py`

**Проверка точности модуля тренда по истории из БД.** Запуск: `python backtest_trend.py [--tf 60] [--bars 20000]`.

### Сравнение методов фаз: `src/scripts/compare_phase_methods.py` и лаунчер `compare_phase_methods.py`

**Сравнение трёх способов определения фазы:** только Вайкофф (`phase_wyckoff`), только индикаторы (`phase_indicators`), только price action / BOS-CHOCH (`phase_structure`). Один и тот же бэктест по БД — вывод точности по направлению для каждого метода. Запуск: `python compare_phase_methods.py [--tf 60] [--bars 20000] [--step 5]`. Для продакшена используется основной `market_phases.py` (Вайкофф + индикаторы).

### Бэктест фаз: `src/scripts/backtest_phases.py` и лаунчер `backtest_phases.py`

**Проверка точности фаз по истории из БД.** Скользящее окно → `detect_phase` → форвард-доходность; «точность по направлению». Запуск: `python backtest_phases.py [--tf 60] [--bars 20000] [--forward 20] [--step 5]`. **`--min-score 0.6`** — только бары с score ≥ 0.6. **`--tune`** — подбор порогов.

### `refresh_db.py` (в корне)

**Полное обновление БД:** удаление файла БД и загрузка всех таймфреймов из `TIMEFRAMES_DB` с биржи. Запуск: `python refresh_db.py [--yes]`. Перед запуском останови бота. Без подтверждения: `--yes`.

### `refill_tf_d.py` (в корне)

**Перезалив только ТФ D:** удаление всех свечей по паре и ТФ D, затем загрузка истории заново с Bybit (с фильтром нереалистичных цен). Запуск: `python refill_tf_d.py`. Используется, если по ТФ D попали некорректные цены.

### `catch_up_db.py` (в корне)

**Догрузка БД до текущей даты:** подтягивает пропущенные свечи от последней в БД до «сейчас» по всем ТФ из `TIMEFRAMES_DB`. Запуск: `python catch_up_db.py`. Выводит дату последней свечи (ТФ D и 60).

### `src/scripts/full_backfill.py` и лаунчер `full_backfill.py`

**Полный бэкфилл за весь период Bybit.** Запуск: `python full_backfill.py [--clear] [--extend]`.

- **`--extend`** — углубление истории от текущей самой старой свечи по каждому ТФ. При `AUTO_EXTEND_AT_STARTUP=1` то же самое делается автоматически при каждом старте бота/main/telegram_bot, так что ручной `--extend` нужен только для разовой глубокой подгонки без запуска приложений (например, при выключенном авто-углублении).

### `src/scripts/test_run_once.py` и лаунчер `test_run_once.py`

**Один прогон анализа для теста.** Запуск: `python test_run_once.py`.

---

### `src/app/telegram_bot.py` и лаунчер `telegram_bot.py`

**Управление ботом через Telegram.** Логика в `src/app/telegram_bot.py`. Токен → `TELEGRAM_BOT_TOKEN` в .env.

Команды: `/start` — старт и нижняя панель кнопок; `/signal` — полный разбор (сигнал, фазы по ТФ, с эмодзи); `/status` — одна строка: сигнал и старший ТФ; `/db` — статистика БД; `/backtest_phases` — график бэктеста фаз; `/chart` — свечной график с трендами Вверх/Вниз/Флэт (из БД, ТФ D, до 1500 свечей); `/id` — твой user id для TELEGRAM_ALLOWED_IDS; `/help` — справка. Под ответами «Сигнал» и «БД» — inline-кнопки «Обновить» и переключение на другую страницу. Длинные сообщения отправляются частями. В меню бота (слева от поля ввода) отображается список команд. Ограничение доступа: `TELEGRAM_ALLOWED_IDS=123,456` в .env.

Запуск: отдельно `python telegram_bot.py` или вместе с основным ботом — при `python main.py` и заданном `TELEGRAM_BOT_TOKEN` бот поднимается в отдельном потоке. Остановка — Ctrl+C.

---

### Остальное

- **`.env.example`** — пример переменных окружения. Копируют в `.env`; в репо не коммитить `.env`.
- **`.gitignore`** — `.env`, `data/`, `logs/`, venv, кэши.
- **`requirements.txt`** — зависимости: `pybit`, `python-dotenv`, `pandas`, `numpy`.
- **`README.md`** — установка, настройка, команды, структура папок, версии и GitHub.
- **`AGENT_CONTEXT.md`** — контекст для ИИ: что сделано, в процессе, планируется.
- **`check_all.py`** — проверка окружения и конфига (в т.ч. .env, БД, выбросы цен для BTC, импорты, сеть, Telegram, визуализация). Запуск: `python check_all.py [--quick] [-v]`. `--quick` — без сетевых проверок.

---

## Как всё связано (потоки данных)

```
.env ──► src/core/config.py (PROJECT_ROOT, .env из корня)
              │
              ├──► src/core/exchange.py ◄── Bybit REST API (свечи)
              │         │
              │         ├──► src/scripts/accumulate_db.py ──► src/core/database.py ──► data/klines.db
              │         │
              │         └──► src/analysis/multi_tf.py (+ market_phases) ──► src/app/main.py (лог сигналов)
              │
              └──► src/core/database.py (путь к БД от PROJECT_ROOT)
```

- **Накопление данных:** `src/scripts/accumulate_db` через `src/core/exchange` тянет свечи с Bybit и пишет в `src/core/database` → `data/klines.db`.
- **Сигналы:** `src/app/main` → `src/analysis/multi_tf` → при `DATA_SOURCE=db` свечи читаются из БД (через переданное соединение); при `DATA_SOURCE=exchange` — запрос к Bybit на каждый тик.

---

## Что задаётся в `.env`

| Переменная | Назначение | Пример |
|------------|------------|--------|
| `BYBIT_API_KEY` / `BYBIT_API_SECRET` | Ключи API (для чтения свечей не нужны) | — |
| `BYBIT_TESTNET` | Тестовая сеть да/нет | `true` / `false` |
| `BYBIT_CATEGORY` | Режим: linear / inverse / spot | `linear` |
| `SYMBOL` | Торговая пара | `BTCUSDT` |
| `TIMEFRAMES` | Таймфреймы для сигнального бота | `15,60,240` |
| `KLINE_LIMIT` | Сколько свечей за раз с биржи | `200` |
| `POLL_INTERVAL_SEC` | Интервал опроса в main.py, сек | `60` |
| `PHASE_SCORE_MIN` | Мин. score фазы для «подтверждённого» сигнала (0..1) | `0.6` |
| `PHASE_UNCLEAR_THRESHOLD`, `PHASE_MIN_GAP`, `PHASE_STABILITY_MIN`, `PHASE_HISTORY_SIZE` | Пороги фазы: неясность, разрыв score, устойчивость, размер истории | см. .env.example |
| `TREND_STRENGTH_MIN`, `TREND_UNCLEAR_THRESHOLD`, `TREND_MIN_GAP`, `TREND_STABILITY_MIN` | Пороги тренда (модуль market_trend) | см. .env.example |
| `VOLUME_MIN_RATIO`, `ATR_MAX_RATIO`, `TF_ALIGN_MIN`, `LEVEL_MAX_DISTANCE_PCT`, `REGIME_BLOCK_SURGE` | Фильтры входа: объём, ATR, совпадение ТФ, расстояние до уровней, блок при режиме «всплеск» (1/0) | 0 = отключено; REGIME_BLOCK_SURGE=1 |
| `ENTRY_SCORE_WEIGHT_PHASE`, `ENTRY_SCORE_WEIGHT_TREND`, `ENTRY_SCORE_WEIGHT_TF_ALIGN` | Веса единого score входа (фаза, тренд, совпадение ТФ) | 0.4, 0.35, 0.25 |
| `CANDLE_QUALITY_MIN_SCORE` | Мин. quality_score (0..1) для использования ТФ; 0 = не проверять | 0 |
| `DATA_SOURCE` | Источник свечей для анализа: db (из БД) или exchange (с биржи каждый тик) | `db` |
| `SIGNAL_MIN_CONFIDENCE` | Мин. уверенность сигнала (0..1) для фильтра; 0 — не фильтровать | `0` |
| `EXCHANGE_MAX_RETRIES` | Макс. попыток запроса к Bybit при rate limit / сбое | `5` |
| `EXCHANGE_RETRY_BACKOFF_SEC` | Базовая задержка (с) между попытками | `1` |
| `DB_PATH` | Файл SQLite для свечей | `data/klines.db` |
| `TIMEFRAMES_DB` | Таймфреймы для накопления в БД | `1,3,5,15,30,60,120,240,360,720,D,W,M` |
| `BACKFILL_MAX_CANDLES` | Лимит свечей вглубь при первом бэкфилле на один ТФ | `50000` |
| `DB_UPDATE_INTERVAL_SEC` | Как часто дотягивать новые свечи в accumulate_db, сек | `60` |
| `AUTO_EXTEND_AT_STARTUP` | При подготовке БД автоматически углублять историю по всем ТФ (1/0) | `1` |
| `LOG_DIR` | Каталог логов (пусто = проект/logs) | — |
| `LOG_LEVEL` | Уровень лога в консоль: DEBUG, INFO, WARNING, ERROR | `INFO` |
| `LOG_LEVEL_FILE` | Уровень лога в файл (по умолчанию = LOG_LEVEL) | — |
| `LOG_FILE_MAX_MB` | Макс. размер одного лог-файла, МБ | `10` |
| `LOG_BACKUP_COUNT` | Число старых файлов при ротации | `7` |
| `LOG_SIGNALS_FILE` | Писать отдельно signals.log (1/0) | `1` |
| `TELEGRAM_BOT_TOKEN` | Токен бота от @BotFather для управления через Telegram | — |
| `TELEGRAM_ALLOWED_IDS` | Разрешённые user id через запятую (пусто = все). Узнать: /id в боте | `123,456` |

---

## Как запустить и проверить

1. **Окружение и зависимости**

   ```bash
   python -m venv .venv
   .venv\Scripts\activate
   pip install -r requirements.txt
   ```

2. **Конфиг**
   - Скопировать `.env.example` в `.env`.
   - Для начала достаточно задать `SYMBOL=BTCUSDT`, `BYBIT_CATEGORY=linear`, при необходимости — `BYBIT_TESTNET=true`.

3. **Накопление БД**

   ```bash
   python accumulate_db.py
   ```

   Первый запуск может быть долгим (бэкфилл по всем ТФ). Дальше скрипт просто раз в минуту добавляет новые свечи.

4. **Сигнальный бот (без сделок)**

   ```bash
   python main.py
   ```

   В логе появятся сигналы и тренды по таймфреймам.

---

## Куда смотреть, если нужно что-то менять

- Добавить пару или ТФ для накопления → `.env`: `SYMBOL`, `TIMEFRAMES_DB`.
- Поменять логику сигнала (индикаторы, пороги) → `src/analysis/multi_tf.py`, фазы — `src/analysis/market_phases.py`.
- Проверить точность фаз по истории → `python backtest_phases.py [--tf 60] [--min-score 0.6]`; подбор порогов — `--tune`. Проверить точность тренда → `python backtest_trend.py [--tf 60]`. Сравнить методы фаз (Wyckoff / индикаторы / PA) → `python compare_phase_methods.py [--tf 60]`.
- Подключить сделки по сигналу → новый модуль (ордера через Bybit) и вызов из `src/app/main.py` по `signals.direction`.
- Читать данные для обучения из БД → `src/core/database.py` даёт соединение и выборки.
- Сделать версию и выгрузить в GitHub / откатиться → `release.py` в корне, см. README.

Если что-то из этого станет общим правилом — можно дописать в этот файл отдельным пунктом.
