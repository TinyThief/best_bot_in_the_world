# Как устроен бот — для нового человека в проекте

Краткий обзор: что это за проект, что уже сделано, за что отвечает каждый файл и как всё связано.

---

## Что это за проект

**Мультитаймфреймовый торговый бот для биржи Bybit.**

Идея: торговать (пока в планах), опираясь на анализ нескольких таймфреймов — тренд со старшего ТФ и вход с младшего. Сейчас реализовано:

1. **Подключение к Bybit** и загрузка свечей по любым таймфреймам.
2. **База данных для обучения** — SQLite с историей OHLCV по фьючерсу BTC на всех таймфреймах; база наращивается со временем.
3. **Черновая логика мультитаймфреймового анализа** — тренд по старшему ТФ и результирующий сигнал (long/short/none). Пока без реальных сделок.

Торговля ордерами, индикаторы (MA, RSI и т.п.) и риск-менеджмент — в планах, в коде их ещё нет.

---

## Что уже сделано (кратко)

| Готово | Описание |
|--------|----------|
| ✅ | Клиент Bybit (REST, публичные данные): свечи «последние N» и по диапазону start/end |
| ✅ | Бэкфилл истории: пагинация по 1000 свечей, загрузка вглубь до лимита |
| ✅ | SQLite-база `klines`: symbol, timeframe, start_time, open, high, low, close, volume |
| ✅ | Скрипт накопления БД: при первом запуске — бэкфилл по всем ТФ, потом — периодическое дополнение новыми свечами |
| ✅ | Модуль мультитаймфреймового анализа: тренд по ТФ, 6 фаз рынка, агрегированный сигнал по старшему ТФ |
| ✅ | Определение фаз: RSI, объём у границ, дивергенция RSI, Spring/Upthrust, сила тренда, свежесть зоны, контекст старшего ТФ |
| ✅ | Бэктест точности фаз по БД (`backtest_phases.py`), в т.ч. фильтр `--min-score` и подбор порогов `--tune` |
| ✅ | Конфиг через `.env`, разделение настроек для «торгового» бота и для «базы под обучение» |
| ⏳ | Реальные сделки, риск-менеджмент — не делали |

---

## Структура по папкам

- **src/core/** — инфраструктура: конфиг (`config.py`), БД (`database.py`), биржа Bybit (`exchange.py`).
- **src/analysis/** — аналитика: фазы рынка (`market_phases.py`), мультитаймфреймовый разбор и сигнал (`multi_tf.py`).
- **src/app/** — приложения: точка входа и цикл (`main.py`), один тик бота — БД + анализ + лог (`bot_loop.py`), синхронизация БД (`db_sync.py`), Telegram-бот (`telegram_bot.py`).
- **src/scripts/** — скрипты: накопление БД (`accumulate_db.py`), бэктест фаз (`backtest_phases.py`), полный бэкфилл (`full_backfill.py`), тест-прогон (`test_run_once.py`). Импорты из `..core` и `..analysis`.
- **Корень** — точки входа (`main.py`, `telegram_bot.py`, `accumulate_db.py`, `backtest_phases.py`, `full_backfill.py`, `test_run_once.py`) только поднимают `sys.path` и вызывают модули из `src.app` или `src.scripts`. Здесь же `release.py`, `requirements.txt`, `.env.example`, документация, `check_all.py`.
- **data/** — каталог для SQLite-базы (`data/klines.db` по умолчанию), в .gitignore.

Запуск из корня: `python main.py`, `python accumulate_db.py`, `python backtest_phases.py` и т.д.

---

## За что отвечает каждый файл

### `src/core/config.py`

**Настройки приложения.** Читает `.env` из корня проекта (`PROJECT_ROOT`), экспортирует константы.

- Bybit: `BYBIT_API_KEY`, `BYBIT_API_SECRET`, `BYBIT_TESTNET`, `BYBIT_CATEGORY`
- Торговый режим: `SYMBOL`, `TIMEFRAMES`, `KLINE_LIMIT`, `POLL_INTERVAL_SEC`, `DATA_SOURCE` (db/exchange), `SIGNAL_MIN_CONFIDENCE`, `EXCHANGE_MAX_RETRIES`, `EXCHANGE_RETRY_BACKOFF_SEC`
- База для обучения: `DB_PATH` (по умолчанию `PROJECT_ROOT/data/klines.db`), `TIMEFRAMES_DB`, `BACKFILL_MAX_CANDLES`, `DB_UPDATE_INTERVAL_SEC`, `AUTO_EXTEND_AT_STARTUP` (1/0 — автоматически углублять историю по всем ТФ при подготовке БД).
- Логирование: `LOG_DIR` (каталог, по умолчанию `PROJECT_ROOT/logs`), `LOG_LEVEL`, `LOG_LEVEL_FILE`, `LOG_FILE_MAX_MB`, `LOG_BACKUP_COUNT`, `LOG_SIGNALS_FILE` (1/0 — отдельный файл сигналов).

Есть `validate_config()`, `PROJECT_ROOT`.

---

### `src/core/logging_config.py`

**Единая настройка логирования.** Вызывается в начале `main`, `telegram_bot`, `accumulate_db`, `full_backfill`.

- **`setup_logging()`** — идемпотентно настраивает: вывод в консоль; ротируемый файл `logs/bot.log` (по умолчанию до 10 МБ, 7 архивов); при `LOG_SIGNALS_FILE=1` — компактный `logs/signals.log` (одна строка на каждый тик: direction, reason, higher_tf_phase). В файле в каждой строке есть модуль, функция и номер строки. Уровни задаются через `LOG_LEVEL` и `LOG_LEVEL_FILE`.
- **`get_signals_logger()`** — логгер для записи в `signals.log` (используется из `bot_loop`).

---

### `src/core/exchange.py`

**Всё общение с биржей Bybit.** Используется библиотека `pybit` (REST API V5).

- **`get_klines(...)`** — запрос свечей: пара, интервал, лимит, опционально `start_ms`/`end_ms`. Возвращает список словарей `{ start_time, open, high, low, close, volume }` в порядке от старых к новым.
- **`get_klines_multi_timeframe(...)`** — те же свечи, но сразу по нескольким таймфреймам; результат — словарь `{ "15": [...], "60": [...], ... }`.
- **`fetch_klines_backfill(...)`** — загрузка истории вглубь от заданного `end_ms`: пагинация по 1000 свечей, пока не наберётся `max_candles` или данные не кончатся. Нужна для первоначального наполнения БД.

Интервалы Bybit: `1,3,5,15,30,60,120,240,360,720,D,W,M`. Категории: `linear` (USDT-фьючерсы), `inverse`, `spot`.

---

### `src/core/database.py`

**Работа с локальной базой свечей.** Одна SQLite-база, одна таблица `klines`.

- **Схема:** `(symbol, timeframe, start_time, open, high, low, close, volume)`, первичный ключ `(symbol, timeframe, start_time)`.
- **`get_db_path()`** — путь к файлу БД из конфига (по умолчанию `data/klines.db`).
- **`get_connection()`** — открывает соединение и при первом обращении создаёт таблицу и индекс.
- **`init_db()`** — создаёт файл/таблицу, если их ещё нет.
- **`insert_candles(cursor, symbol, timeframe, candles)`** — вставляет список свечей; дубликаты по `(symbol, timeframe, start_time)` игнорируются (`INSERT OR IGNORE`). Возвращает количество реально вставленных строк.
- **`get_latest_start_time(cursor, symbol, timeframe)`** — `start_time` последней свечи по этой паре и ТФ (или `None`).
- **`get_oldest_start_time(...)`** — самая старая свеча по паре/ТФ.
- **`count_candles(...)`** — число строк, опционально с фильтром по symbol/timeframe.

Используется и для накопления данных, и (в перспективе) для чтения при обучении моделей.

---

### `src/scripts/accumulate_db.py`

**Скрипт, который наполняет и поддерживает базу свечей.** Точка входа для «накопления данных под обучение». Лаунчер в корне: `accumulate_db.py`.

- При старте проверяет `TIMEFRAMES_DB`; если пусто — пишет в лог и выходит.
- Создаёт/открывает БД, затем в цикле по каждому таймфрейму из `TIMEFRAMES_DB`:
  - если по этому ТФ в БД ещё нет данных — делает **бэкфилл** через `exchange.fetch_klines_backfill(...)` (до `BACKFILL_MAX_CANDLES` свечей) и вставляет в БД;
  - в любом случае **дотягивает последние свечи** через `exchange.get_klines(...)` и вставляет только новые.
- **`run_extend_until_done(conn)`** — по каждому ТФ подгружает историю вглубь от самой старой свечи, пока есть новые данные; используется из `db_sync.open_and_prepare()` при `AUTO_EXTEND_AT_STARTUP=1`, чтобы по всем ТФ (в т.ч. 3m) глубина нарастала автоматически без ручного `full_backfill.py --extend`.
- После первого полного прохода засыпает на `DB_UPDATE_INTERVAL_SEC` секунд и снова дотягивает новые свечи по всем ТФ. Так база постоянно растёт.

Пара и категория берутся из конфига (`SYMBOL`, `BYBIT_CATEGORY`). Для чтения свечей ключи API не обязательны.

Запуск: `python accumulate_db.py`. Остановка — Ctrl+C.

---

### `src/analysis/multi_tf.py`

**Мультитаймфреймовый анализ и сигнал.** Тренд по ТФ, 6 фаз рынка (через `market_phases`), направление по старшему ТФ.

- **`analyze_multi_timeframe(...)`** — запрашивает свечи по всем заданным таймфреймам (`exchange.get_klines_multi_timeframe`), для каждого ТФ считает «тренд» по последним свечам (`up`/`down`/`flat`), определяет старший ТФ и по нему выдаёт:
  - `higher_tf_trend`
  - `signals.direction`: `"long"` / `"short"` / `"none"`
  - `signals.reason` — текстовая подсказка.

Использует настройки `SYMBOL` и `TIMEFRAMES` из конфига (не `TIMEFRAMES_DB`). При `DATA_SOURCE=db` и переданном соединении с БД читает свечи из локальной БД (меньше запросов к бирже); при `DATA_SOURCE=exchange` или без БД — запрос к Bybit на каждый вызов. В сигнале добавлены `confidence` (0..1) и `confidence_level` (weak/medium/strong). В дальнейшем — индикаторы и риск-менеджмент.

---

### `src/app/main.py` и лаунчер `main.py`

**Точка входа «сигнального» бота.** В `main.py` только цикл и запуск: валидация конфига, подготовка БД через `db_sync`, в цикле — `bot_loop.run_one_tick()` и пауза `POLL_INTERVAL_SEC`. Сделок не открывает. Остановка — Ctrl+C. Запуск: `python main.py`.

### `src/app/bot_loop.py`

**Один тик цикла бота.** Функция `run_one_tick(db_conn, last_db_ts)` обновляет БД по таймеру (`db_sync.refresh_if_due`), запускает мультиТФ-анализ (`analyze_multi_timeframe`) и пишет результат в лог. Вся логика «что делать за один шаг» собрана здесь; `main.py` только вызывает `run_one_tick` в цикле.

### `src/app/db_sync.py`

**Синхронизация БД с биржей во время работы бота.** Используется из `main.py` и Telegram-бота. Функции: `open_and_prepare()` — инициализация, бэкфилл по пустым ТФ, догрузка пропусков, при `AUTO_EXTEND_AT_STARTUP=1` — автоматическое углубление истории по всем ТФ до упора (возвращает соединение или `None`); `refresh_if_due(conn, last_ts)` — при истечении интервала подтягивает новые свечи; `close(conn)` — закрытие соединения. Логика: `scripts.accumulate_db.run_once`, `run_catch_up`, `run_extend_until_done`.

---

### `release.py` (в корне)

**Версии и выгрузка в GitHub.** Создаёт тег версии (например `v1.0.0`), при наличии изменений — коммитит их, пушит текущую ветку и теги в `origin`. Откат: `git checkout v1.0.0`.

- `python release.py 1.0.0` — коммит (если есть изменения), тег `v1.0.0`, push ветки и тега.
- `python release.py 1.0.1 --tag-only` — только тег и push тега, без коммита.
- `python release.py 1.0.0 --no-push` — коммит и тег локально, без отправки.
- Откат: `git checkout v1.0.0`. Список тегов: `git tag -l`.

Перед первым использованием: `git init`, `git remote add origin <url>`.

---

### `src/analysis/market_phases.py`

**6 фаз рынка (Wyckoff-подобная схема):** accumulation, markup, distribution, markdown, capitulation, recovery. `detect_phase(candles, ...)` по OHLCV возвращает phase, phase_ru, score, details. Учитываются: структура, позиция в диапазоне, RSI, объём у границ, дивергенция RSI, Spring/Upthrust, сила тренда, свежесть зоны, контекст старшего ТФ. Капитуляция = «ожидаем отскок». Используется в `multi_tf` по каждому ТФ.

### Бэктест фаз: `src/scripts/backtest_phases.py` и лаунчер `backtest_phases.py`

**Проверка точности фаз по истории из БД.** Скользящее окно → `detect_phase` → форвард-доходность; «точность по направлению». Запуск: `python backtest_phases.py [--tf 60] [--bars 20000] [--forward 20] [--step 5]`. **`--min-score 0.6`** — только бары с score ≥ 0.6. **`--tune`** — подбор порогов.

### `src/scripts/full_backfill.py` и лаунчер `full_backfill.py`

**Полный бэкфилл за весь период Bybit.** Запуск: `python full_backfill.py [--clear] [--extend]`.

- **`--extend`** — углубление истории от текущей самой старой свечи по каждому ТФ. При `AUTO_EXTEND_AT_STARTUP=1` то же самое делается автоматически при каждом старте бота/main/telegram_bot, так что ручной `--extend` нужен только для разовой глубокой подгонки без запуска приложений (например, при выключенном авто-углублении).

### `src/scripts/test_run_once.py` и лаунчер `test_run_once.py`

**Один прогон анализа для теста.** Запуск: `python test_run_once.py`.

---

### `src/app/telegram_bot.py` и лаунчер `telegram_bot.py`

**Управление ботом через Telegram.** Логика в `src/app/telegram_bot.py`. Токен → `TELEGRAM_BOT_TOKEN` в .env.

Команды: `/start` — старт и нижняя панель кнопок; `/signal` — полный разбор (сигнал, фазы по ТФ, с эмодзи); `/status` — одна строка: сигнал и старший ТФ; `/db` — статистика БД; `/id` — твой user id для TELEGRAM_ALLOWED_IDS; `/help` — справка. Под ответами «Сигнал» и «БД» — inline-кнопки «Обновить» и переключение на другую страницу. Длинные сообщения отправляются частями. В меню бота (слева от поля ввода) отображается список команд. Ограничение доступа: `TELEGRAM_ALLOWED_IDS=123,456` в .env.

Запуск: `python telegram_bot.py`. Остановка — Ctrl+C.

---

### Остальное

- **`.env.example`** — пример переменных окружения. Копируют в `.env`; в репо не коммитить `.env`.
- **`.gitignore`** — `.env`, `data/`, venv, кэши.
- **`requirements.txt`** — зависимости: `pybit`, `python-dotenv`, `pandas`, `numpy`.
- **`README.md`** — установка, настройка, команды, структура папок, версии и GitHub.
- **`AGENT_CONTEXT.md`** — контекст для ИИ: что сделано, в процессе, планируется.

---

## Как всё связано (потоки данных)

```
.env ──► src/core/config.py (PROJECT_ROOT, .env из корня)
              │
              ├──► src/core/exchange.py ◄── Bybit REST API (свечи)
              │         │
              │         ├──► src/scripts/accumulate_db.py ──► src/core/database.py ──► data/klines.db
              │         │
              │         └──► src/analysis/multi_tf.py (+ market_phases) ──► src/app/main.py (лог сигналов)
              │
              └──► src/core/database.py (путь к БД от PROJECT_ROOT)
```

- **Накопление данных:** `src/scripts/accumulate_db` через `src/core/exchange` тянет свечи с Bybit и пишет в `src/core/database` → `data/klines.db`.
- **Сигналы:** `src/app/main` → `src/analysis/multi_tf` → `src/core/exchange`; свечи с биржи на лету, БД в этом цикле не используется.

---

## Что задаётся в `.env`

| Переменная | Назначение | Пример |
|------------|------------|--------|
| `BYBIT_API_KEY` / `BYBIT_API_SECRET` | Ключи API (для чтения свечей не нужны) | — |
| `BYBIT_TESTNET` | Тестовая сеть да/нет | `true` / `false` |
| `BYBIT_CATEGORY` | Режим: linear / inverse / spot | `linear` |
| `SYMBOL` | Торговая пара | `BTCUSDT` |
| `TIMEFRAMES` | Таймфреймы для сигнального бота | `15,60,240` |
| `KLINE_LIMIT` | Сколько свечей за раз с биржи | `200` |
| `POLL_INTERVAL_SEC` | Интервал опроса в main.py, сек | `60` |
| `PHASE_SCORE_MIN` | Мин. score фазы для «подтверждённого» сигнала (0..1) | `0.6` |
| `DATA_SOURCE` | Источник свечей для анализа: db (из БД) или exchange (с биржи каждый тик) | `db` |
| `SIGNAL_MIN_CONFIDENCE` | Мин. уверенность сигнала (0..1) для фильтра; 0 — не фильтровать | `0` |
| `EXCHANGE_MAX_RETRIES` | Макс. попыток запроса к Bybit при rate limit / сбое | `5` |
| `EXCHANGE_RETRY_BACKOFF_SEC` | Базовая задержка (с) между попытками | `1` |
| `DB_PATH` | Файл SQLite для свечей | `data/klines.db` |
| `TIMEFRAMES_DB` | Таймфреймы для накопления в БД | `1,3,5,15,30,60,120,240,360,720,D,W,M` |
| `BACKFILL_MAX_CANDLES` | Лимит свечей вглубь при первом бэкфилле на один ТФ | `50000` |
| `DB_UPDATE_INTERVAL_SEC` | Как часто дотягивать новые свечи в accumulate_db, сек | `60` |
| `AUTO_EXTEND_AT_STARTUP` | При подготовке БД автоматически углублять историю по всем ТФ (1/0) | `1` |
| `LOG_DIR` | Каталог логов (пусто = проект/logs) | — |
| `LOG_LEVEL` | Уровень лога в консоль: DEBUG, INFO, WARNING, ERROR | `INFO` |
| `LOG_LEVEL_FILE` | Уровень лога в файл (по умолчанию = LOG_LEVEL) | — |
| `LOG_FILE_MAX_MB` | Макс. размер одного лог-файла, МБ | `10` |
| `LOG_BACKUP_COUNT` | Число старых файлов при ротации | `7` |
| `LOG_SIGNALS_FILE` | Писать отдельно signals.log (1/0) | `1` |
| `TELEGRAM_BOT_TOKEN` | Токен бота от @BotFather для управления через Telegram | — |
| `TELEGRAM_ALLOWED_IDS` | Разрешённые user id через запятую (пусто = все). Узнать: /id в боте | `123,456` |

---

## Как запустить и проверить

1. **Окружение и зависимости**

   ```bash
   python -m venv .venv
   .venv\Scripts\activate
   pip install -r requirements.txt
   ```

2. **Конфиг**
   - Скопировать `.env.example` в `.env`.
   - Для начала достаточно задать `SYMBOL=BTCUSDT`, `BYBIT_CATEGORY=linear`, при необходимости — `BYBIT_TESTNET=true`.

3. **Накопление БД**

   ```bash
   python accumulate_db.py
   ```

   Первый запуск может быть долгим (бэкфилл по всем ТФ). Дальше скрипт просто раз в минуту добавляет новые свечи.

4. **Сигнальный бот (без сделок)**

   ```bash
   python main.py
   ```

   В логе появятся сигналы и тренды по таймфреймам.

---

## Куда смотреть, если нужно что-то менять

- Добавить пару или ТФ для накопления → `.env`: `SYMBOL`, `TIMEFRAMES_DB`.
- Поменять логику сигнала (индикаторы, пороги) → `src/analysis/multi_tf.py`, фазы — `src/analysis/market_phases.py`.
- Проверить точность фаз по истории → `python backtest_phases.py [--tf 60] [--min-score 0.6]`; подбор порогов — `--tune`.
- Подключить сделки по сигналу → новый модуль (ордера через Bybit) и вызов из `src/app/main.py` по `signals.direction`.
- Читать данные для обучения из БД → `src/core/database.py` даёт соединение и выборки.
- Сделать версию и выгрузить в GitHub / откатиться → `release.py` в корне, см. README.

Если что-то из этого станет общим правилом — можно дописать в этот файл отдельным пунктом.
