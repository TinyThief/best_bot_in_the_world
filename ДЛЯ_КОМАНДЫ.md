# Как устроен бот — для нового человека в проекте

Краткий обзор: что это за проект, что уже сделано, за что отвечает каждый файл и как всё связано.

---

## Что это за проект

**Мультитаймфреймовый торговый бот для биржи Bybit.**

Идея: торговать (пока в планах), опираясь на анализ нескольких таймфреймов — тренд со старшего ТФ и вход с младшего. Сейчас реализовано:

1. **Подключение к Bybit** и загрузка свечей по любым таймфреймам.
2. **База данных для обучения** — SQLite с историей OHLCV по фьючерсу BTC на всех таймфреймах; база наращивается со временем.
3. **Черновая логика мультитаймфреймового анализа** — тренд по старшему ТФ и результирующий сигнал (long/short/none). Пока без реальных сделок.

Торговля ордерами, индикаторы (MA, RSI и т.п.) и риск-менеджмент — в планах, в коде их ещё нет.

---

## Что уже сделано (кратко)

| Готово | Описание |
|--------|----------|
| ✅ | Клиент Bybit (REST, публичные данные): свечи «последние N» и по диапазону start/end |
| ✅ | Бэкфилл истории: пагинация по 1000 свечей, загрузка вглубь до лимита |
| ✅ | SQLite-база `klines`: symbol, timeframe, start_time, open, high, low, close, volume |
| ✅ | Скрипт накопления БД: при первом запуске — бэкфилл по всем ТФ, потом — периодическое дополнение новыми свечами |
| ✅ | Модуль мультитаймфреймового анализа: тренд по ТФ, агрегированный сигнал по старшему ТФ |
| ✅ | Конфиг через `.env`, разделение настроек для «торгового» бота и для «базы под обучение» |
| ⏳ | Реальные сделки, индикаторы, риск-менеджмент — не делали |

---

## За что отвечает каждый файл

### `config.py`
**Настройки приложения.** Читает переменные из `.env` (через `python-dotenv`) и экспортирует их как константы.

- Bybit: `BYBIT_API_KEY`, `BYBIT_API_SECRET`, `BYBIT_TESTNET`, `BYBIT_CATEGORY`
- Торговый режим: `SYMBOL`, `TIMEFRAMES`, `KLINE_LIMIT`, `POLL_INTERVAL_SEC`
- База для обучения: `DB_PATH`, `TIMEFRAMES_DB`, `BACKFILL_MAX_CANDLES`, `DB_UPDATE_INTERVAL_SEC`

Есть `validate_config()` — возвращает список строк с ошибками (например, пустой `SYMBOL`). Импортировать настройки нужно через `import config`.

---

### `exchange.py`
**Всё общение с биржей Bybit.** Используется библиотека `pybit` (REST API V5).

- **`get_klines(...)`** — запрос свечей: пара, интервал, лимит, опционально `start_ms`/`end_ms`. Возвращает список словарей `{ start_time, open, high, low, close, volume }` в порядке от старых к новым.
- **`get_klines_multi_timeframe(...)`** — те же свечи, но сразу по нескольким таймфреймам; результат — словарь `{ "15": [...], "60": [...], ... }`.
- **`fetch_klines_backfill(...)`** — загрузка истории вглубь от заданного `end_ms`: пагинация по 1000 свечей, пока не наберётся `max_candles` или данные не кончатся. Нужна для первоначального наполнения БД.

Интервалы Bybit: `1,3,5,15,30,60,120,240,360,720,D,W,M`. Категории: `linear` (USDT-фьючерсы), `inverse`, `spot`.

---

### `database.py`
**Работа с локальной базой свечей.** Одна SQLite-база, одна таблица `klines`.

- **Схема:** `(symbol, timeframe, start_time, open, high, low, close, volume)`, первичный ключ `(symbol, timeframe, start_time)`.
- **`get_db_path()`** — путь к файлу БД из конфига (по умолчанию `data/klines.db`).
- **`get_connection()`** — открывает соединение и при первом обращении создаёт таблицу и индекс.
- **`init_db()`** — создаёт файл/таблицу, если их ещё нет.
- **`insert_candles(cursor, symbol, timeframe, candles)`** — вставляет список свечей; дубликаты по `(symbol, timeframe, start_time)` игнорируются (`INSERT OR IGNORE`). Возвращает количество реально вставленных строк.
- **`get_latest_start_time(cursor, symbol, timeframe)`** — `start_time` последней свечи по этой паре и ТФ (или `None`).
- **`get_oldest_start_time(...)`** — самая старая свеча по паре/ТФ.
- **`count_candles(...)`** — число строк, опционально с фильтром по symbol/timeframe.

Используется и для накопления данных, и (в перспективе) для чтения при обучении моделей.

---

### `accumulate_db.py`
**Скрипт, который наполняет и поддерживает базу свечей.** Точка входа для «накопления данных под обучение».

- При старте проверяет `TIMEFRAMES_DB`; если пусто — пишет в лог и выходит.
- Создаёт/открывает БД, затем в цикле по каждому таймфрейму из `TIMEFRAMES_DB`:
  - если по этому ТФ в БД ещё нет данных — делает **бэкфилл** через `exchange.fetch_klines_backfill(...)` (до `BACKFILL_MAX_CANDLES` свечей) и вставляет в БД;
  - в любом случае **дотягивает последние свечи** через `exchange.get_klines(...)` и вставляет только новые.
- После первого полного прохода засыпает на `DB_UPDATE_INTERVAL_SEC` секунд и снова дотягивает новые свечи по всем ТФ. Так база постоянно растёт.

Пара и категория берутся из конфига (`SYMBOL`, `BYBIT_CATEGORY`). Для чтения свечей ключи API не обязательны.

Запуск: `python accumulate_db.py`. Остановка — Ctrl+C.

---

### `multi_tf.py`
**Мультитаймфреймовый анализ и сигнал.** Пока упрощённая логика «по старшему ТФ решаем направление».

- **`analyze_multi_timeframe(...)`** — запрашивает свечи по всем заданным таймфреймам (`exchange.get_klines_multi_timeframe`), для каждого ТФ считает «тренд» по последним свечам (`up`/`down`/`flat`), определяет старший ТФ и по нему выдаёт:
  - `higher_tf_trend`
  - `signals.direction`: `"long"` / `"short"` / `"none"`
  - `signals.reason` — текстовая подсказка.

Использует настройки `SYMBOL` и `TIMEFRAMES` из конфига (не `TIMEFRAMES_DB`). Данные берёт напрямую с биржи, не из БД. В дальнейшем сюда можно добавить индикаторы и чтение из БД.

---

### `main.py`
**Точка входа «сигнального» бота.** Цикл с интервалом `POLL_INTERVAL_SEC`:

- вызывает `multi_tf.analyze_multi_timeframe()`;
- логирует сигнал, причину и тренд по старшему ТФ, плюс по каждому ТФ — тренд и число свечей.

Сделок не открывает. Остановка — Ctrl+C.

Запуск: `python main.py`.

---

### `release.py`
**Версии и выгрузка в GitHub.** Создаёт тег версии (например `v1.0.0`), при наличии изменений — коммитит их, пушит текущую ветку и теги в `origin`. Нужен, чтобы можно было откатиться на любую версию.

- `python release.py 1.0.0` — коммит (если есть изменения), тег `v1.0.0`, push ветки и тега.
- `python release.py 1.0.1 --tag-only` — только тег и push тега, без коммита.
- `python release.py 1.0.0 --no-push` — коммит и тег локально, без отправки.
- Откат: `git checkout v1.0.0`. Список тегов: `git tag -l`.

Перед первым использованием: `git init`, `git remote add origin <url>`.

---

### Остальное

- **`.env.example`** — пример переменных окружения. Копируют в `.env` и подставляют свои значения; в репозиторий коммитится только `.env.example`.
- **`.gitignore`** — в него добавлены `.env`, `data/`, виртуальные окружения, кэши.
- **`requirements.txt`** — зависимости: `pybit`, `python-dotenv`, `pandas`, `numpy`.
- **`README.md`** — установка, настройка, команды запуска, структура проекта, версии и GitHub, дальнейшие шаги.
- **`AGENT_CONTEXT.md`** — контекст для ИИ-агента: что сделано, что в процессе, что планируется (обновляется по ходу работы).

---

## Как всё связано (потоки данных)

```
.env ──► config.py
              │
              ├──► exchange.py ◄── Bybit REST API (свечи)
              │         │
              │         ├──► accumulate_db.py ──► database.py ──► data/klines.db
              │         │
              │         └──► multi_tf.py ──► main.py (лог сигналов)
              │
              └──► database.py (путь к БД, и при чтении для обучения)
```

- **Накопление данных:** `accumulate_db` через `exchange` тянет свечи с Bybit и пишет в `database` → файл `data/klines.db`.
- **Сигналы:** `main` → `multi_tf` → `exchange`; свечи запрашиваются с биржи на лету, БД в этом цикле не используется.

---

## Что задаётся в `.env`

| Переменная | Назначение | Пример |
|------------|------------|--------|
| `BYBIT_API_KEY` / `BYBIT_API_SECRET` | Ключи API (для чтения свечей не нужны) | — |
| `BYBIT_TESTNET` | Тестовая сеть да/нет | `true` / `false` |
| `BYBIT_CATEGORY` | Режим: linear / inverse / spot | `linear` |
| `SYMBOL` | Торговая пара | `BTCUSDT` |
| `TIMEFRAMES` | Таймфреймы для сигнального бота | `15,60,240` |
| `KLINE_LIMIT` | Сколько свечей за раз с биржи | `200` |
| `POLL_INTERVAL_SEC` | Интервал опроса в main.py, сек | `60` |
| `DB_PATH` | Файл SQLite для свечей | `data/klines.db` |
| `TIMEFRAMES_DB` | Таймфреймы для накопления в БД | `1,3,5,15,30,60,120,240,360,720,D,W,M` |
| `BACKFILL_MAX_CANDLES` | Лимит свечей вглубь при первом бэкфилле на один ТФ | `50000` |
| `DB_UPDATE_INTERVAL_SEC` | Как часто дотягивать новые свечи в accumulate_db, сек | `60` |

---

## Как запустить и проверить

1. **Окружение и зависимости**
   ```bash
   python -m venv .venv
   .venv\Scripts\activate
   pip install -r requirements.txt
   ```

2. **Конфиг**
   - Скопировать `.env.example` в `.env`.
   - Для начала достаточно задать `SYMBOL=BTCUSDT`, `BYBIT_CATEGORY=linear`, при необходимости — `BYBIT_TESTNET=true`.

3. **Накопление БД**
   ```bash
   python accumulate_db.py
   ```
   Первый запуск может быть долгим (бэкфилл по всем ТФ). Дальше скрипт просто раз в минуту добавляет новые свечи.

4. **Сигнальный бот (без сделок)**
   ```bash
   python main.py
   ```
   В логе появятся сигналы и тренды по таймфреймам.

---

## Куда смотреть, если нужно что-то менять

- Добавить пару или ТФ для накопления → `.env`: `SYMBOL`, `TIMEFRAMES_DB`.
- Поменять логику сигнала (индикаторы, пороги) → `multi_tf.py`.
- Подключить сделки по сигналу → новый модуль (ордера через Bybit) и вызов из `main.py` по `signals.direction`.
- Читать данные для обучения из БД → `database.py` уже даёт соединение и выборки; удобно обернуть в функции вида «дать последние N свечей по symbol/timeframe» или «дать диапазон дат».
- Сделать версию и выгрузить в GitHub / откатиться → `release.py`, см. раздел про `release.py` выше и README.

Если что-то из этого станет общим правилом — можно дописать в этот файл отдельным пунктом.
