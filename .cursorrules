# Правила разработки торгового бота (best_bot_in_the_world)

## Контекст
- Мультитаймфреймовый бот для **Bybit** (pybit, REST V5). Пара по умолчанию — BTCUSDT (linear).
- Структура: **src/core**, **src/analysis** (market_phases, market_trend, multi_tf), **src/app**, **src/scripts**, **src/utils**; **bin/** (скрипты БД и бэктестов); **strategies/**; **tests/** (unit, integration, backtest). В корне — main.py, telegram_bot.py, check_all.py, release.py; остальные скрипты в bin/, запуск из корня: python bin/script.py.
- Подробный контекст: **AGENT_CONTEXT.md**, **ДЛЯ_КОМАНДЫ.md**. Правила Cursor: **.cursor/rules/**.

## Безопасность
- Никогда не хардкодить API-ключи, токены, секреты. Только .env и os.getenv().
- .gitignore: .env, data/, logs/, секреты.

## Код
- Type hints для сигнатур. Имена: snake_case (функции/переменные), PascalCase (классы).
- Импорты между пакетами — относительные (from ..core import config).
- Ошибки API и сетевые сбои — ретраи с экспоненциальной задержкой; логировать с контекстом.

## Проверки
- После изменений запускать **python check_all.py** (при необходимости -v или --quick).
- Тесты добавлять в **tests/unit**, **tests/integration**, **tests/backtest**.

## Логи и данные прогона (run_id и БД)

- Данные, привязанные к одному прогону/сессии (бэктест, лайв, скрипт), идентифицируются по **run_id** и хранятся в БД (таблицы runs + детальные с FK run_id). Отчёты — по run_id или по дате. Подробно: **.cursor/rules/run-id-and-db-logging.mdc**.
- Песочница: уже по run_id в `sandbox_runs`, `sandbox_trades`, `sandbox_skips`; отчёт: `--db [--run-id ...] [--year ...]`. Новые append-логи по прогону — по тому же принципу (run_id + БД) или архивировать файл перед новым запуском (`*_archive_YYYYMMDD_HHMMSS.*`).
- Ротируемые логи (bot.log, signals.log) не трогать. Не дописывать в один файл/таблицу результаты разных прогонов без run_id или без архивирования.

## Функционал (без наслоения логики)

- **Одна точка принятия решения** по фиче: например, вход/выход песочницы решает только MicrostructureSandbox; лайв и бэктест только передают ему данные (тренд, orderflow). Новый функционал — по возможности параметры или данные для этой точки, а не новая ветка в нескольких местах.
- **Не дублировать логику:** если условие или расчёт уже есть (в анализе, в песочнице и т.д.), не копировать в другой модуль — передавать результат параметром или вызывать общий код.
- **Новые режимы/опции:** при добавлении нового способа поведения описать в коде или в AGENT_CONTEXT, как он сочетается с существующими; конфиг (config.py / .env) — единое место для опций, при новой опции проверять все места, где читается конфиг этой фичи (main, backtest, telegram и т.д.).
- **Рефактор при разрастании:** если одна и та же проверка или ветка повторяется в нескольких местах — вынести в функцию/стратегию вместо нагромождения if/else.

## Чего избегать
- Глобального изменяемого состояния для бизнес-логики.
- Игнорирования rate limit и ошибок API.
- Логирования балансов и ключей.
- Хардкода порогов и путей — выносить в конфиг/.env.
