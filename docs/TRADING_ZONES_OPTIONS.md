# Торговые зоны — варианты реализации

Сейчас в системе есть:
- **Фаза** (accumulation, markup, …) и **тренд** (up/down/flat).
- **Свинг-уровни** (`swing_levels`) — один `swing_low` и один `swing_high` по последним окнам, плюс `distance_to_support_pct` / `distance_to_resistance_pct`.
- Фильтр входа `LEVEL_MAX_DISTANCE_PCT` — «входить только если цена в пределах N% от уровня».

Ниже — что может означать «торговые зоны» и как это можно добавить.

---

## 1. Что понимать под «торговыми зонами»

Возможные варианты:

| Вариант | Описание | Пример использования |
|--------|----------|----------------------|
| **A. Несколько уровней S/R** | Список значимых ценовых уровней (поддержка/сопротивление), а не один низ/верх | «Цена у 3-й поддержки», «между уровнями», фильтр входа по ближайшему уровню |
| **B. Supply/Demand зоны** | Диапазоны цен, откуда цена резко ушла (свечной импульс + объём) — «зона спроса»/«зона предложения» | Вход в лонг в зоне спроса при восходящем тренде |
| **C. Текущая «зона» цены** | Классификация: «в зоне поддержки», «в зоне сопротивления», «нейтрально», «между уровнями» | Один признак для фильтра и риска, без списка зон |
| **D. Диапазоны консолидации** | Горизонтальные коридоры, где цена долго торговалась (низкая ATR/диапазон) | Потенциальные зоны пробоя или накопления |

Можно реализовать один вариант или комбинацию (например, A + C).

---

## 2. Варианты реализации

### Вариант A. Несколько уровней поддержки/сопротивления

**Идея:** Строить список значимых уровней по свинг-точкам и, при желании, по объёму/касаниям.

**Как считать уровни:**
- **Свинг-пивоты:** локальные минимумы/максимумы (соседи слева и справа ниже/выше). Берём последние N свингов, группируем близкие цены в один уровень (кластеризация по порогу % или ATR).
- **Сила уровня:** число касаний, объём на уровне, «свежесть» (недавно ли тестировали). Можно выдавать топ-3–5 уровней сверху и снизу от текущей цены.

**Выход:** список уровней, например:
```python
[
  {"price": 95000, "type": "support", "strength": 0.8, "touches": 3},
  {"price": 97000, "type": "resistance", "strength": 0.6, "touches": 2},
]
```
Плюс для текущей цены: `nearest_support`, `nearest_resistance`, `distance_to_nearest_support_pct`, `between_levels` (bool).

**Плюсы:** привычная механика S/R, хорошо стыкуется с фазами и трендом.  
**Минусы:** нужно задать параметры (окно для свингов, порог кластеризации, сколько уровней хранить).

---

### Вариант B. Supply/Demand зоны

**Идея:** Зона спроса (demand) — диапазон цен перед резким ростом; зона предложения (supply) — перед резким падением. Часто ищут «свечной импульс» (длинное тело) + объём.

**Как считать:**
- Сканировать историю: ищем свечи с большим телом (|close - open| / ATR > k) и, при желании, повышенным объёмом.
- Зона = диапазон цен (например, low–high этой свечи или последних 2–3 свечей до импульса). Или базовая свеча + расширение на X%.
- Храним зоны с меткой времени (или «возрастом» в барах). Зона «использована», если цена потом заходила в неё и ушла в сторону импульса (можно не реализовывать сразу).
- Для текущего бара: «цена в зоне спроса» / «в зоне предложения» / «нет».

**Выход:** список зон и/или флаги `in_demand_zone`, `in_supply_zone`, опционально `nearest_demand_zone`, `nearest_supply_zone`.

**Плюсы:** хорошо ложится на «вход в зоне спроса при тренде вверх».  
**Минусы:** больше эвристик (размер импульса, объём, размер зоны, инвалидация при повторном тесте).

---

### Вариант C. Классификация «текущая зона» (без списка зон)

**Идея:** Не строить список зон, а по текущей цене и уже имеющимся данным выдать один признак: в какой «зоне» мы находимся.

**Как считать:**
- Используем уже имеющиеся `swing_levels` (или будущие уровни из варианта A).
- Правила: например, если `distance_to_support_pct` < 1% → «у поддержки»; если `distance_to_resistance_pct` < 1% → «у сопротивления»; если оба > 5% → «между уровнями»; и т.д.
- Опционально учитывать тренд: «у поддержки в восходящем тренде» = «зона покупки».

**Выход:** одно поле, например `price_zone`: `"at_support"` | `"at_resistance"` | `"between"` | `"above_range"` | `"below_range"`, и/или `zone_quality`: 0..1 (насколько «чисто» мы в зоне).

**Плюсы:** минимальные изменения, переиспользуем `swing_levels`, легко встроить в фильтры и лог.  
**Минусы:** грубая гранулярность, нет нескольких уровней.

---

### Вариант D. Диапазоны консолидации

**Идея:** Находить горизонтальные коридоры (низкая волатильность, узкий диапазон high–low за окно).

**Как считать:**
- Скользящее окно: ATR или (high - low) за окно. Если ATR < k * median(ATR) за больший период — считаем консолидацией.
- Зона = [min(low), max(high)] за это окно. При пробое (close выше/ниже зоны с объёмом) зона «закрыта».
- Для текущей цены: «в консолидации» / «вышли из консолидации вверх/вниз».

**Плюсы:** полезно для пробоев и для контекста (накопление/флэт).  
**Минусы:** отдельный блок логики, нужно определять пробой и инвалидацию зоны.

---

## 3. Интеграция с текущей системой

- **Фаза + тренд** уже есть; зоны дают **где** входить (уровень/зона), а не только **когда** (фаза + тренд).
- **Фильтр входа:** уже есть `LEVEL_MAX_DISTANCE_PCT`; при варианте A можно заменить «один swing_low/high» на «ближайший уровень из списка»; при варианте C — использовать `price_zone` (например, разрешать вход только `at_support` для лонга).
- **Лог/Telegram:** выводить текущую зону и, при варианте A, ближайшие уровни.
- **Риск (позже):** стоп за ближайшим уровнем, размер позиции от «качества» зоны.

---

## 4. Рекомендуемый порядок внедрения

1. **Быстро и с пользой:** вариант **C** (классификация «текущая зона») на базе существующих `swing_levels` — один новый признак в отчёте и в фильтрах.
2. **Расширение:** вариант **A** (несколько уровней S/R по свинг-пивотам + кластеризация) — даёт список уровней и `nearest_support`/`nearest_resistance`; фильтр и логика могут опираться на них.
3. **По желанию:** вариант **B** (Supply/Demand) — если нужна отдельная стратегия «вход в зоне спроса/предложения».

Напиши, какой вариант тебе ближе (A, B, C, D или комбинация), и можно перейти к конкретному алгоритму и сигнатурам функций.
