# Модуль торговых зон: дизайн

## Цель

Мощный модуль определения **торговых зон/уровней**, которые:
- **Переходят друг в друга** с движением рынка (resistance после пробоя становится support, и наоборот).
- Бот понимает и анализирует: «было сопротивление → пробой вверх → теперь это поддержка».

## Ключевые понятия

| Термин | Описание |
|--------|----------|
| **Уровень** | Значимая цена (свинг-хай или свинг-лоу). |
| **Роль по происхождению (origin_role)** | Как уровень образовался: **support** (свинг-лоу) или **resistance** (свинг-хай). |
| **Текущая роль (current_role)** | Как уровень действует сейчас: **support** или **resistance**. После пробоя роль меняется (flip). |
| **Пробой (breakout)** | Цена закрылась выше сопротивления → уровень «перевернулся» в поддержку; закрылась ниже поддержки → уровень стал сопротивлением. |
| **Зона** | Диапазон между двумя уровнями; текущая цена находится «в зоне» между ближайшей поддержкой снизу и сопротивлением сверху. |

## Логика переключения ролей

1. **Уровень образовался как сопротивление** (свинг-хай). Пока цена ниже — это сопротивление. Как только цена **закрылась выше** уровня — **пробой вверх**: уровень становится **поддержкой** (на откатах цена может от него оттолкнуться вверх).
2. **Уровень образовался как поддержка** (свинг-лоу). Пока цена выше — это поддержка. Как только цена **закрылась ниже** уровня — **пробой вниз**: уровень становится **сопротивлением** (на отскоках цена может от него оттолкнуться вниз).

Один и тот же уровень в разное время имеет разную текущую роль — модуль это явно хранит и отдаёт.

## Алгоритм (этапы)

### 1. Поиск свинг-точек (pivots)

- **Свинг-лоу:** локальный минимум — `low[i]` не больше соседей слева и справа в окне (например, по 2–5 баров с каждой стороны).
- **Свинг-хай:** локальный максимум — `high[i]` не меньше соседей.
- Для каждой точки: цена, индекс/время бара, `origin_role`: support | resistance.

Параметры: `left_bars`, `right_bars` (или общий `pivot_strength` = 2..5).

### 2. Кластеризация уровней

- Близкие по цене уровни объединяем в один (порог в % от цены или в ATR).
- После объединения: одна цена уровня (например, медиана кластера), список «касаний» (сколько раз цена тестировала уровень), сила (число касаний + свежесть).
- Ограничение: хранить топ N уровней (например, до 10–15) по силе/свежести.

### 3. Определение пробоев и текущей роли

- Для каждого уровня и истории свечей от момента образования уровня до текущего бара:
  - **origin_role = resistance:** если хотя бы раз `close > level` → уровень пробит вверх → **current_role = support**.
  - **origin_role = support:** если хотя бы раз `close < level` → уровень пробит вниз → **current_role = resistance**.
- Опционально: хранить бар/время последнего пробоя, чтобы помечать «недавно перевернувшиеся» уровни.

### 4. Текущий контекст для бота

По текущей цене (последнее close):

- **Ближайшая поддержка снизу** — уровень с `current_role = support` и `price < close`, максимум по price.
- **Ближайшее сопротивление сверху** — уровень с `current_role = resistance` и `price > close`, минимум по price.
- **Текущая зона** — «между уровнем A (support) и уровнем B (resistance)»; можно вернуть границы и название/ид зоны.
- **Недавние перевороты** — уровни, у которых роль сменилась за последние K баров (для логов и аналитики).

## Структуры данных (предложение)

### Уровень (Level)

```python
{
    "price": float,           # цена уровня
    "origin_role": "support" | "resistance",  # как образовался
    "current_role": "support" | "resistance", # текущая роль (после возможного flip)
    "broken": bool,            # был ли пробой (роль сменилась)
    "broken_at_bar": int | None,  # индекс бара пробоя (опционально)
    "touches": int,            # число касаний (тестов) уровня
    "strength": float,         # 0..1, сила уровня (касания, свежесть)
    "bar_index": int,          # индекс бара образования (или start_time)
}
```

### Ответ модуля (TradingZonesResult)

```python
{
    "levels": list[Level],                    # все отслеживаемые уровни
    "nearest_support": Level | None,          # ближайшая поддержка снизу
    "nearest_resistance": Level | None,       # ближайшее сопротивление сверху
    "zone_low": float | None,                 # низ текущей зоны (support price)
    "zone_high": float | None,                # верх текущей зоны (resistance price)
    "in_zone": bool,                          # цена между zone_low и zone_high
    "recent_flips": list[Level],              # уровни, недавно сменившие роль
    "distance_to_support_pct": float | None,   # (close - support) / close
    "distance_to_resistance_pct": float | None,  # (resistance - close) / close
}
```

## Интеграция

- **multi_tf.py:** по каждому ТФ (или только по старшему) вызывать `detect_trading_zones(candles)` и класть результат в отчёт (уровни, nearest_support/resistance, zone, recent_flips).
- **Фильтры входа:** разрешать лонг только «у поддержки» (близко к nearest_support), шорт — «у сопротивления»; опционально учитывать недавние перевороты (вход после подтверждённого flip).
- **Лог/Telegram:** выводить текущую зону, ближайшие уровни и их роли, недавние перевороты («сопротивление 97k стало поддержкой»).

## Файлы

- **`src/analysis/trading_zones.py`** — единственный модуль: поиск пивотов, кластеризация, пробои, текущая роль, зона и контекст для бота.
